trigger: none

resources:
  repositories:
    - repository: appCode
      type: git
      name: myproject/netflix
      ref: main
    
    - repository: gitOpsRepo
      type: github
      endpoint: github-conn
      name: muzzammil-hamdu/netflix-argocd-deploy-helm
      ref: main

variables:
  dockerHubUser: "mujju752"
  imageName: "netflix"
  valuesFile: "charts/netflix/values.yaml"

stages:

- stage: Build
  displayName: "Build and Push Image"
  jobs:
    - job: BuildImage
      pool:
        name: projectpool
        demands: agent.name -equals projectagent

      steps:
        - checkout: appCode
          persistCredentials: false
          clean: true

        - script: |
            echo "Building Netflix application from Azure Repos"
            ls -la
          displayName: "Verify Application Code"

        - task: Docker@2
          displayName: "Build and Push Docker Image"
          inputs:
            command: buildAndPush
            containerRegistry: dockerhub-conn
            repository: "$(dockerHubUser)/$(imageName)"
            dockerfile: "**/Dockerfile"
            tags: |
              $(Build.BuildId)
              latest

- stage: UpdateGitOps
  dependsOn: Build
  displayName: "Update GitHub GitOps Repo"

  jobs:
    - job: UpdateGitHub
      pool:
        name: projectpool
        demands: agent.name -equals projectagent

      steps:
        - checkout: gitOpsRepo
          persistCredentials: true
          clean: true

        - script: |
            sudo apt-get update -y
            sudo snap install yq
          displayName: "Install yq"

        - script: |
            echo "Working in GitHub GitOps repository"
            echo "Repository: muzzammil-hamdu/netflix-argocd-deploy-helm"
            ls -la
            
            if [ -d "charts/netflix" ]; then
              ls -la charts/netflix/
            else
              echo "Warning: charts/netflix directory not found"
              find . -type d -name "netflix" 2>/dev/null
            fi
          displayName: "Verify GitOps Repository"

        - script: |
            echo "Verifying values.yaml exists..."
            
            if [ ! -f "$(valuesFile)" ]; then
              echo "ERROR: $(valuesFile) not found"
              find . -name "values.yaml" -type f
              exit 1
            fi
            
            echo "Found values.yaml"
            echo "Current content:"
            cat "$(valuesFile)"
          displayName: "Verify values.yaml"

        - script: |
            echo "Updating values.yaml with new image..."
            echo "New image: $(dockerHubUser)/$(imageName):$(Build.BuildId)"
            
            yq -i '.image.repository = "$(dockerHubUser)/$(imageName)" | .image.tag = "$(Build.BuildId)"' "$(valuesFile)"

            echo "Updated content:"
            cat "$(valuesFile)"
          displayName: "Update values.yaml"

        - script: |
            echo "Configuring Git..."
            git config user.email "azurepipeline@devops.com"
            git config user.name "Azure Pipeline Bot"
            
            echo "Staging changes..."
            git add "$(valuesFile)"
            
            if git diff --staged --quiet; then
              echo "No changes to commit"
              exit 0
            fi

            echo "Committing changes..."
            git commit -m "Deploy: $(dockerHubUser)/$(imageName):$(Build.BuildId)"

            echo "Pushing to GitHub..."
            git push origin main
            
            echo "Successfully pushed to GitHub"
          displayName: "Commit and Push to GitHub"

- stage: Validate
  dependsOn: UpdateGitOps
  displayName: "Validate or Rollback"

  jobs:
    - job: ValidateApp
      pool:
        name: projectpool
        demands: agent.name -equals projectagent

      steps:
        - checkout: gitOpsRepo
          persistCredentials: true
          clean: true

        - script: |
            echo "Waiting 90 seconds for ArgoCD to sync..."
            sleep 90
          displayName: "Wait for ArgoCD Sync"

        - script: |
            echo "Validating Kubernetes deployment..."
            
            if ! kubectl get namespace netflix &>/dev/null; then
              echo "Namespace netflix does not exist"
              kubectl get namespaces
              exit 1
            fi
            
            DEPLOY_COUNT=$(kubectl get deploy -n netflix --no-headers 2>/dev/null | wc -l)
            if [ "$DEPLOY_COUNT" -eq 0 ]; then
              echo "No deployments found in netflix namespace"
              kubectl get all -n netflix
              exit 1
            fi
            
            DEPLOY_NAME=$(kubectl get deploy -n netflix -o jsonpath='{.items[0].metadata.name}')
            echo "Checking deployment: $DEPLOY_NAME"
            
            DESIRED=$(kubectl get deploy $DEPLOY_NAME -n netflix -o jsonpath='{.spec.replicas}')
            READY=$(kubectl get deploy $DEPLOY_NAME -n netflix -o jsonpath='{.status.readyReplicas}')
            UNAVAILABLE=$(kubectl get deploy $DEPLOY_NAME -n netflix -o jsonpath='{.status.unavailableReplicas}')
            
            echo "Desired: ${DESIRED:-0}"
            echo "Ready: ${READY:-0}"
            echo "Unavailable: ${UNAVAILABLE:-0}"
            
            if [ "${READY:-0}" -eq "${DESIRED:-0}" ] && [ -z "$UNAVAILABLE" ]; then
              echo "DEPLOYMENT SUCCESSFUL"
              kubectl get pods -n netflix
              exit 0
            else
              echo "DEPLOYMENT FAILED"
              kubectl get pods -n netflix
              kubectl describe pods -n netflix
              exit 1
            fi
          name: healthCheck
          continueOnError: true
          displayName: "Validate Deployment"

        - script: |
            echo "INITIATING ROLLBACK"
            
            if ! command -v yq &> /dev/null; then
              sudo snap install yq
            fi
            
            git fetch --unshallow 2>/dev/null || git fetch --all
            
            PREVIOUS=$(git log -n 10 --pretty=format:"%s" | grep "Deploy:" | grep -oP '(?<=: )[^ ]+' | sed -n '2p')
            
            if [ -z "$PREVIOUS" ]; then
              echo "No previous deployment found"
              REPO="$(dockerHubUser)/$(imageName)"
              TAG="latest"
            else
              echo "Found previous deployment: $PREVIOUS"
              REPO=$(echo $PREVIOUS | cut -d ':' -f1)
              TAG=$(echo $PREVIOUS | cut -d ':' -f2)
            fi
            
            echo "Rolling back to: $REPO:$TAG"
            
            yq -i ".image.repository = \"$REPO\" | .image.tag = \"$TAG\"" "$(valuesFile)"
            
            echo "Rolled back values.yaml:"
            cat "$(valuesFile)"
            
            git config user.email "azurepipeline@devops.com"
            git config user.name "Azure Pipeline Bot"
            git add "$(valuesFile)"
            git commit -m "ROLLBACK to $REPO:$TAG - Build $(Build.BuildId) failed"
            
            git push origin main
            
            echo "Rollback pushed to GitHub"
            
            sleep 60
            
            echo "Status after rollback:"
            kubectl get deployments -n netflix
            kubectl get pods -n netflix
            
          condition: failed()
          displayName: "Automatic Rollback"